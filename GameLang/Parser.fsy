%{
open Ast
%}

// The start token becomes a parser function in the compiled code:
%start start

// Regular tokens
%token < string > IDENTIFIER
%token < string > STRING
%token < double > NUMBER
%token OPEN_PAREN
%token CLOSE_PAREN
%token ATOM_NIL
%token DEFINE_MACRO
%token DOT
%token BEGIN
%token TRUE
%token FALSE
%token LAMBDA
%token LET
%token LET_STAR
%token IF
%token DEFINE
%token QUOTE
%token QUOTE_STRING
%token QUASIQUOTE
%token UNQUOTE
%token UNQUOTE_SPLICING
%token SET


// Misc tokens
%token EOF

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type < Ast.SObject list > start

%%

// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced.  
start: File EOF						{ $1 }

File:
	| Sexpr_Plus					{ $1 }

Sexpr_Plus:
	| Sexpr							{ [ $1 ] }
	| Sexpr_Plus Sexpr				{ List.append $1 [ $2 ] }

Sexpr:
	| Macro							{ $1 }
	| Begin							{ $1 }
	| Define						{ $1 }
	| If							{ $1 }
	| Let_Star						{ $1 }
	| Let							{ $1 }
	| Lambda						{ $1 }
	| Quote							{ $1 }
	| Set							{ $1 }
	| Quasiquote					{ $1 }
	| Unquote						{ $1 }
	| List							{ $1 }
	| Atom							{ $1 }

List:
	| OPEN_PAREN CLOSE_PAREN		{ NIL }
	| OPEN_PAREN Sexpr_Consed CLOSE_PAREN	{ $2 }

Atom:
	| ATOM_NIL						{ NIL }
	| TRUE							{ True }
	| FALSE							{ False }
	| Identifier					{ $1 }
	| STRING						{ String($1) }
	| NUMBER						{ Number($1) }

Identifier:
	| IDENTIFIER					{ Atom($1) }

Sexpr_Consed:
	| Sexpr							{ Cons($1, NIL) }
	| Sexpr_Consed Sexpr			{ AppendCons $1 $2 }

Id_Consed:
	| Identifier					{ Cons($1, NIL) }
	| Id_Consed Identifier			{ AppendCons ($1) (Cons($2, NIL)) }

Rest:
	| IDENTIFIER					{ $1 }

Id_Consed_With_Rest:
	| Id_Consed						{ $1 }
	| Id_Consed DOT Rest			{ AppendCons ($1) (Cons(Rest($3), NIL)) }

List_of_Identifiers:
	| OPEN_PAREN CLOSE_PAREN				{ NIL }
	| OPEN_PAREN Atom_Consed CLOSE_PAREN	{ $2 }

Atom_Consed:
	| Atom							{ Cons($1, NIL) }
	| Atom_Consed Atom				{ AppendCons $1 $2 }

Lambda:
	| OPEN_PAREN LAMBDA List_of_Identifiers Sexpr CLOSE_PAREN { Lambda($3, $4) }

If:
	| OPEN_PAREN IF Sexpr Sexpr Sexpr CLOSE_PAREN	{ If($3, $4, $5) }

Define:
	| OPEN_PAREN DEFINE Identifier Sexpr CLOSE_PAREN { Define($3, $4) }

Let:
	| OPEN_PAREN LET OPEN_PAREN Let_Binding_Plus CLOSE_PAREN Sexpr_Plus CLOSE_PAREN	{ Let($4, $6) }

Let_Star:
	| OPEN_PAREN LET_STAR OPEN_PAREN Let_Binding_Plus CLOSE_PAREN Sexpr_Plus CLOSE_PAREN	{ Let_Star($4, $6) }

Let_Binding_Plus:
	| Let_Binding					{ Cons($1, NIL)}
	| Let_Binding_Plus Let_Binding	{ AppendCons $1 $2 }

Let_Binding: 
	| OPEN_PAREN Atom Sexpr CLOSE_PAREN	{ Cons($2, $3) }

Quote:
	| OPEN_PAREN QUOTE_STRING Sexpr CLOSE_PAREN { Quote($3) }
	| QUOTE Sexpr { Quote($2) }

Unquote:
	| UNQUOTE Sexpr							{ Unquote($2) }
	| UNQUOTE_SPLICING Sexpr				{ UnquoteSplicing($2) }

Set:
	| OPEN_PAREN SET Atom Sexpr CLOSE_PAREN			{ Set($3, $4)}

Begin:
	| OPEN_PAREN BEGIN Sexpr_Plus CLOSE_PAREN		{ Begin($3) }

// -----------------------------------------------------------------

Quasiquote:
	| QUASIQUOTE Sexpr					{ Quasiquote($2) }

// -----------------------------------------------------------------

Macro:
	| OPEN_PAREN DEFINE_MACRO OPEN_PAREN Id_Consed_With_Rest CLOSE_PAREN Sexpr CLOSE_PAREN { DefineMacro($4, $6) }